<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quaternion Mapping Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: #000;
            color: #e2e8f0;
        }
        #canvas-container {
            flex-grow: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
            border-radius: 0.45rem;
            margin: 1rem;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .controls-container {
            background-color: rgba(26, 26, 26, 0.6);
            padding: 0.5rem;
            border-radius: 0.45rem;
            margin: 0.5rem auto;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            max-width: 800px;
            width: 95%;
        }
        .left-panel, .right-panel {
            display: flex;
            flex-direction: column;
            flex: 1 1 calc(50% - 0.375rem);
            min-width: 200px;
            gap: 0.75rem;
        }
        .slider-group, .input-group, .example-functions {
            display: flex;
            flex-direction: column;
        }
        .bottom-group {
            margin-top: auto;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .input-group.has-error-message {
            position: relative;
            padding-bottom: 1.5rem;
        }
        .slider-group label, .input-group label {
            margin-bottom: 0.2rem;
            font-weight: bold;
            color: #a0a0a0;
        }
        .slider-group input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 8px;
            background: #333;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        .slider-group input[type="range"]:hover {
            opacity: 1;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #bbb;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .slider-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #bbb;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .value-display {
            font-weight: normal;
            margin-left: 0.5rem;
            color: #ddd;
        }
        .input-group input[type="text"],
        .input-group select {
            padding: 0.5rem;
            border-radius: 0.3rem;
            border: 1px solid #333;
            background-color: #222;
            color: #e2e8f0;
            width: 100%;
        }
        .input-group select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23a0a0a0%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-6.5%200-12.3%203.2-16.1%208.1-3.9%204.9-4.8%2011.8-2.6%2017.9l139.3%20220.4c3.9%206.2%2010.8%209.6%2018.2%209.6s14.3-3.4%2018.2-9.6L289.6%2090.8c2.2-6.1%201.3-13-2.6-17.9z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 0.7em top 50%, 0 0;
            background-size: 0.65em auto, 100%;
        }
        .button-group-single {
            padding: 0.6rem 1rem;
            border-radius: 0.3rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            background-color: #444;
            color: white;
        }
        .button-group-single:hover {
            transform: translateY(-1px);
            background-color: #666;
        }
        .button-group-single:active {
            transform: translateY(0);
            background-color: #444;
        }
        #errorMessage {
            color: #fc8181;
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            font-size: 0.75rem;
            transform: translateY(100%);
            padding-top: 0.2rem;
        }
        .example-functions {
            font-size: 0.85rem;
            color: #a0a0a0;
            line-height: 1.3;
        }
        #coordinatesDisplayDiv {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            pointer-events: none; /* Allows mouse events to pass through to the canvas */
            display: none; /* Initially hidden */
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="coordinatesDisplayDiv"></div>

    <div class="controls-container">

        <div class="left-panel">
            <div class="example-functions">
                Operations supported: (+), (-), (*), (/), (^ integer), norm(), conj(), inv(), re(), im(), w_comp(), x_comp(), y_comp(), z_comp()<br>
                Variables: q (input quaternion), i, j, k
            </div>
            <div class="input-group has-error-message">
                <label for="functionInput">Function:</label>
                <input type="text" id="functionInput" value="q^2">
                <div id="errorMessage" class="text-red-400"></div>
            </div>

            <div class="bottom-group">
                <div class="input-group">
                    <label for="lineDisplayMode">Show Lines between Points:</label>
                    <select id="lineDisplayMode">
                        <option value="none">No Lines</option>
                        <option value="show">Show Lines</option>
                        <option value="faces">Show Faces</option>
                    </select>
                </div>

                </div>
        </div>

        <div class="right-panel">
            <div class="slider-group">
                <label for="wValue">Input w Value: <span id="wValueDisplay" class="value-display">0.5</span></label>
                <input type="range" id="wValue" min="-2" max="2" step="0.01" value="0.5">
            </div>

            <div class="slider-group">
                <label for="density">Point Density: <span id="densityDisplay" class="value-display">10</span></label>
                <input type="range" id="density" min="2" max="30" step="1" value="10">
            </div>

            <div class="slider-group">
                <label for="pointSizeFactor">Point Size Factor: <span id="pointSizeFactorDisplay" class="value-display">1.00</span></label>
                <input type="range" id="pointSizeFactor" min="0.1" max="5.0" step="0.01" value="1.0">
            </div>

            <div class="bottom-group">
                <div class="input-group">
                    <label for="startingArrangement">Starting Arrangement:</label>
                    <select id="startingArrangement">
                        <option value="grid3D">Grid</option>
                        <option value="plane2D">Plane</option>
                        <option value="sphere">Sphere</option>
                        <option value="cubeEdges">Cube Edges</option>
                        <option value="cubeFaces">Cube Faces</option>
                        <option value="grid4D">4D Grid</option>
                        <option value="torus">Torus</option> </select>
                </div>
                <button id="toggleViewBtn" class="button-group-single">Show Mapped View</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let pointsMesh;
        let linesMesh;
        let facesMesh;
        let wFixed = 0.5;
        let density = 10;
        let pointSizeFactor = 1.0;
        let currentFunction = "q^2";
        let showMappedView = true;
        let lineDisplayMode = "none";
        let startingArrangement = "grid3D";

        let originalPointPositions = [];
        let originalPointColors = [];
        let originalLinePositions = [];
        let originalLineColors = [];
        let originalLineIndices = [];
        let originalFacePositions = [];
        let originalFaceColors = [];
        let originalFaceIndices = [];

        let mappedPointPositions = [];
        let mappedPointColors = [];
        let mappedLinePositions = [];
        let mappedLineColors = [];
        let mappedLineIndices = [];
        let mappedFacePositions = [];
        let mappedFaceColors = [];
        let mappedFaceIndices = [];

        let currentTokenIndex = 0;
        let tokens = [];
        let q_input_for_parser;

        // Global arrays for quaternions (populated first, then used for points, lines, faces)
        let originalQuaternions = [];
        let mappedQuaternions = [];


        // Variables for mouse interaction
        let intersected = null;
        let coordinatesDisplayDiv;

        let currentPointPositionsVector3 = [];

        const frustumSize = 2.5;

        function createCircleTexture() {
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');
            context.beginPath();
            context.arc(size / 2, size / 2, size / 2, 0, 2 * Math.PI);
            context.fillStyle = 'white';
            context.fill();
            return new THREE.CanvasTexture(canvas);
        }
        let circleTexture;

        class Quaternion {
            constructor(w, x, y, z) {
                this.w = w;
                this.x = x;
                this.y = y;
                this.z = z;
            }

            multiply(q2) {
                const q1 = this;
                const w = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z;
                const x = q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y;
                const y = q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x;
                const z = q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w;
                return new Quaternion(w, x, y, z);
            }

            add(other) {
                if (other instanceof Quaternion) {
                    return new Quaternion(this.w + other.w, this.x + other.x, this.y + other.y, this.z + other.z);
                } else if (typeof other === 'number') {
                    return new Quaternion(this.w + other, this.x, this.y, this.z);
                }
                throw new Error("Can only add Quaternion or number to Quaternion.");
            }

            subtract(other) {
                if (other instanceof Quaternion) {
                    return new Quaternion(this.w - other.w, this.x - other.x, this.y - other.y, this.z - other.z);
                } else if (typeof other === 'number') {
                    return new Quaternion(this.w - other, this.x, this.y, this.z);
                }
                throw new Error("Can only subtract Quaternion or number from Quaternion.");
            }

            scalarMultiply(scalar) {
                return new Quaternion(this.w * scalar, this.x * scalar, this.y * scalar, this.z * scalar);
            }

            divide(q2) {
                if (!(q2 instanceof Quaternion)) {
                    return new Quaternion(NaN, NaN, NaN, NaN);
                }
                const normSq = q2.w * q2.w + q2.x * q2.x + q2.y * q2.y + q2.z * q2.z;
                if (normSq === 0) {
                    return new Quaternion(NaN, NaN, NaN, NaN);
                }
                const q2_inv = new Quaternion(q2.w / normSq, -q2.x / normSq, -q2.y / normSq, -q2.z / normSq);
                return this.multiply(q2_inv);
            }

            pow(n) {
                if (n === 0) return new Quaternion(1, 0, 0, 0);
                if (n === 1) return this;
                if (n < 0) {
                    const inv = this.inverse();
                    if (isNaN(inv.w)) return new Quaternion(NaN, NaN, NaN, NaN);
                    return inv.pow(Math.abs(n));
                }

                let result = new Quaternion(1, 0, 0, 0);
                let base = this;
                let exponent = n;

                while (exponent > 0) {
                    if (exponent % 2 === 1) {
                        result = result.multiply(base);
                        if (isNaN(result.w)) return new Quaternion(NaN, NaN, NaN, NaN);
                    }
                    base = base.multiply(base);
                    if (isNaN(base.w)) return new Quaternion(NaN, NaN, NaN, NaN);
                    exponent = Math.floor(exponent / 2);
                }
                return result;
            }

            norm() {
                return Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
            }

            conjugate() {
                return new Quaternion(this.w, -this.x, -this.y, -this.z);
            }

            inverse() {
                const normSq = this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z;
                if (normSq === 0) {
                    return new Quaternion(NaN, NaN, NaN, NaN);
                }
                return this.conjugate().scalarMultiply(1 / normSq);
            }

            re() {
                return new Quaternion(this.w, 0, 0, 0);
            }

            im() {
                return new Quaternion(0, this.x, this.y, this.z);
            }

            w_comp() {
                return this.w;
            }

            x_comp() {
                return this.x;
            }

            y_comp() {
                return this.y;
            }

            z_comp() {
                return this.z;
            }
        }

        function tokenize(expression) {
            const tokens = [];
            let i = 0;
            while (i < expression.length) {
                let char = expression[i];
                if (/\s/.test(char)) {
                    i++;
                    continue;
                }

                if (/[0-9]|\./.test(char)) {
                    let numStr = '';
                    while (i < expression.length && (/[0-9]|\./.test(expression[i]))) {
                        numStr += expression[i];
                        i++;
                    }
                    tokens.push({ type: 'NUMBER', value: parseFloat(numStr) });
                    continue;
                }

                if (/[a-zA-Z_]/.test(char)) {
                    let identifier = '';
                    while (i < expression.length && /[a-zA-Z_]/.test(expression[i])) {
                        identifier += expression[i];
                        i++;
                    }
                    if (identifier === 'q') {
                        tokens.push({ type: 'Q' });
                    } else if (identifier === 'i') {
                        tokens.push({ type: 'I' });
                    } else if (identifier === 'j') {
                        tokens.push({ type: 'J' });
                    } else if (identifier === 'k') {
                        tokens.push({ type: 'K' });
                    } else if (['norm', 'conj', 'inv', 're', 'im', 'w_comp', 'x_comp', 'y_comp', 'z_comp'].includes(identifier)) {
                        tokens.push({ type: 'FUNCTION', value: identifier });
                    } else {
                        throw new Error(`Unknown identifier: ${identifier}`);
                    }
                    continue;
                }

                if (['+', '-', '*', '/', '^', '(', ')'].includes(char)) {
                    tokens.push({ type: char });
                    i++;
                    continue;
                }

                throw new Error(`Unexpected character: ${char}`);
            }
            return tokens;
        }

        function parse(expression, q_in) {
            tokens = tokenize(expression);
            currentTokenIndex = 0;
            q_input_for_parser = q_in !== null ? q_in : new Quaternion(0, 0, 0, 0);

            const result = parseExpression();

            if (currentTokenIndex < tokens.length) {
                throw new Error(`Unexpected token at end of expression: ${tokens[currentTokenIndex].type}`);
            }
            return result;
        }

        function consume(expectedType) {
            const token = tokens[currentTokenIndex];
            if (!token || token.type !== expectedType) {
                throw new Error(`Expected ${expectedType} but found ${token ? token.type : 'end of input'}`);
            }
            currentTokenIndex++;
            return token;
        }

        function peek() {
            return tokens[currentTokenIndex];
        }

        function parseExpression() {
            let result = parseTerm();
            while (peek() && (peek().type === '+' || peek().type === '-')) {
                const operator = consume(peek().type).type;
                const right = parseTerm();
                if (operator === '+') {
                    result = result.add(right);
                } else {
                    result = result.subtract(right);
                }
                if (isNaN(result.w)) return new Quaternion(NaN,NaN,NaN,NaN);
            }
            return result;
        }

        function parseTerm() {
            let result = parseFactor();
            while (peek() && (peek().type === '*' || peek().type === '/')) {
                const operator = consume(peek().type).type;
                const right = parseFactor();
                if (operator === '*') {
                    result = result.multiply(right);
                } else {
                    result = result.divide(right);
                }
                if (isNaN(result.w)) return new Quaternion(NaN,NaN,NaN,NaN);
            }
            return result;
        }

        function parseFactor() {
            let result = parsePrimary();
            if (isNaN(result.w)) return new Quaternion(NaN,NaN,NaN,NaN);

            while (peek() &&
                   (peek().type === 'NUMBER' ||
                    peek().type === 'Q' ||
                    peek().type === 'I' ||
                    peek().type === 'J' ||
                    peek().type === 'K' ||
                    peek().type === 'FUNCTION' ||
                    peek().type === '(')) {
                const nextPrimary = parsePrimary();
                if (isNaN(nextPrimary.w)) return new Quaternion(NaN,NaN,NaN,NaN);
                result = result.multiply(nextPrimary);
                if (isNaN(result.w)) return new Quaternion(NaN,NaN,NaN,NaN);
            }
            if (peek() && peek().type === '^') {
                consume('^');
                const exponentToken = peek();
                if (exponentToken && exponentToken.type === 'NUMBER') {
                    const exponent = consume('NUMBER').value;
                    if (Number.isInteger(exponent)) {
                        result = result.pow(exponent);
                        if (isNaN(result.w)) return new Quaternion(NaN,NaN,NaN,NaN);
                    } else {
                        throw new Error("Only integer exponents are supported for quaternion power.");
                    }
                } else {
                    throw new Error("Expected a number for exponent.");
                }
            }
            return result;
        }

        function parsePrimary() {
            const token = peek();
            if (!token) throw new Error("Unexpected end of input.");

            if (token.type === 'NUMBER') {
                return new Quaternion(consume('NUMBER').value, 0, 0, 0);
            } else if (token.type === 'Q') {
                consume('Q');
                return q_input_for_parser;
            } else if (token.type === 'I') {
                consume('I');
                return new Quaternion(0, 1, 0, 0);
            } else if (token.type === 'J') {
                consume('J');
                return new Quaternion(0, 0, 1, 0);
            } else if (token.type === 'K') {
                consume('K');
                return new Quaternion(0, 0, 0, 1);
            }
            else if (token.type === 'FUNCTION') {
                const funcName = consume('FUNCTION').value;
                consume('(');
                const arg = parseExpression();
                consume(')');
                if (isNaN(arg.w)) return new Quaternion(NaN,NaN,NaN,NaN);

                let funcResult;
                switch (funcName) {
                    case 'norm': funcResult = new Quaternion(arg.norm(), 0, 0, 0); break;
                    case 'conj': funcResult = arg.conjugate(); break;
                    case 'inv': funcResult = arg.inverse(); break;
                    case 're': funcResult = arg.re(); break;
                    case 'im': funcResult = arg.im(); break;
                    case 'w_comp': funcResult = new Quaternion(arg.w_comp(), 0, 0, 0); break;
                    case 'x_comp': funcResult = new Quaternion(arg.x_comp(), 0, 0, 0); break;
                    case 'y_comp': funcResult = new Quaternion(arg.y_comp(), 0, 0, 0); break;
                    case 'z_comp': funcResult = new Quaternion(arg.z_comp(), 0, 0, 0); break;
                    default: throw new Error(`Unknown function: ${funcName}`);
                }
                if (isNaN(funcResult.w)) return new Quaternion(NaN,NaN,NaN,NaN);
                return funcResult;
            } else if (token.type === '(') {
                consume('(');
                const result = parseExpression();
                consume(')');
                if (isNaN(result.w)) return new Quaternion(NaN,NaN,NaN,NaN);
                return result;
            } else if (token.type === '-') {
                consume('-');
                const operand = parsePrimary();
                if (isNaN(operand.w)) return new Quaternion(NaN,NaN,NaN,NaN);
                const result = operand.scalarMultiply(-1);
                if (isNaN(result.w)) return new Quaternion(NaN,NaN,NaN,NaN);
                return result;
            } else {
                throw new Error(`Unexpected token: ${token.type}`);
            }
        }

        function evaluateQuaternionExpression(expression, q_in) {
            const errorMessageDiv = document.getElementById('errorMessage');
            if (q_in === null) {
                errorMessageDiv.textContent = ''; // Clear error message for new input
            }

            try {
                expression = expression.trim().toLowerCase();
                if (expression === '') {
                    return new Quaternion(0, 0, 0, 0);
                }
                const result = parse(expression, q_in);
                
                // If the result is a Quaternion but contains NaN components, propagate it.
                // Do NOT set errorMessageDiv here, as it's a mathematical result, not a syntax error.
                if (result instanceof Quaternion && (isNaN(result.w) || isNaN(result.x) || isNaN(result.y) || isNaN(result.z))) {
                    return new Quaternion(NaN, NaN, NaN, NaN);
                }

                // If parsing succeeded and resulted in a valid Quaternion, return it.
                return result;
            } catch (error) {
                // Catch actual parsing/syntax errors (e.g., "q+" or "unknown_func()")
                if (q_in === null) { // Only show syntax errors for the main input field
                    errorMessageDiv.textContent = `Error: ${error.message}`;
                }
                return new Quaternion(NaN, NaN, NaN, NaN); // Return NaN quaternion on parsing errors
            }
        }

        function getColor(value, minVal, maxVal) {
            if (isNaN(value)) {
                return new THREE.Color(0xff0000);
            }
            if (minVal === maxVal) {
                return new THREE.Color(0x808080);
            }

            const normalized = (value - minVal) / (maxVal - minVal);
            const clamped = Math.max(0, Math.min(1, normalized));

            const hue = 240 - (clamped * 240);
            const saturation = 1;
            const lightness = 0.5;

            const c = (1 - Math.abs(2 * lightness - 1)) * saturation;
            const x = c * (1 - Math.abs((hue / 60) % 2 - 1));
            const m = lightness - c / 2;
            let r = 0, g = 0, b = 0;

            if (0 <= hue && hue < 60) {
                r = c; g = x; b = 0;
            } else if (60 <= hue && hue < 120) {
                r = x; g = c; b = 0;
            } else if (120 <= hue && hue < 180) {
                r = 0; g = c; b = x;
            } else if (180 <= hue && hue < 240) {
                r = 0; g = x; b = c;
            } else if (240 <= hue && hue < 300) {
                r = x; g = 0; b = c;
            } else if (300 <= hue && 360 >= hue) {
                r = c; g = 0; b = x;
            }

            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);

            return new THREE.Color(`rgb(${r},${g},${b})`);
        }

        function init() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 3.33;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            circleTexture = createCircleTexture();

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            controls.addEventListener('start', function() {
                coordinatesDisplayDiv.style.display = 'none';
                intersected = null;
            });

            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            const lineDisplayModeSelect = document.getElementById('lineDisplayMode');
            lineDisplayMode = 'none';
            lineDisplayModeSelect.value = lineDisplayMode;

            const startingArrangementSelect = document.getElementById('startingArrangement');
            startingArrangement = 'grid3D';
            startingArrangementSelect.value = startingArrangement;

            coordinatesDisplayDiv = document.getElementById('coordinatesDisplayDiv');
            container.addEventListener('mousemove', onMouseMove, false);

            createVisualization(); // Initial creation of all data
            updateDisplay(); // Initial display based on current settings

            // Set initial button text correctly as it starts in Mapped View
            document.getElementById('toggleViewBtn').textContent = "Show Original View";

            window.addEventListener('resize', onWindowResize, false);

            document.getElementById('wValue').addEventListener('input', (event) => {
                wFixed = parseFloat(event.target.value);
                document.getElementById('wValueDisplay').textContent = wFixed.toFixed(2);
                if (startingArrangement !== 'grid4D') {
                    createVisualization(); // Regenerate data
                }
                updateDisplay(); // Update display
            });

            document.getElementById('density').addEventListener('input', (event) => {
                density = parseInt(event.target.value);
                document.getElementById('densityDisplay').textContent = density;
                createVisualization(); // Regenerate data
                updateDisplay(); // Update display
            });

            document.getElementById('pointSizeFactor').addEventListener('input', (event) => {
                pointSizeFactor = parseFloat(event.target.value);
                document.getElementById('pointSizeFactorDisplay').textContent = pointSizeFactor.toFixed(2);
                updateDisplay(); // Update display (no data regeneration needed)
            });

            document.getElementById('functionInput').addEventListener('input', (event) => {
                currentFunction = event.target.value;
                // Always attempt to create and update, let createVisualization handle NaNs
                createVisualization();
                updateDisplay();
            });

            document.getElementById('toggleViewBtn').addEventListener('click', () => {
                showMappedView = !showMappedView;
                document.getElementById('toggleViewBtn').textContent = showMappedView ? "Show Original View" : "Show Mapped View";
                updateDisplay(); // Update display (no data regeneration needed)
            });

            lineDisplayModeSelect.addEventListener('change', (event) => {
                lineDisplayMode = event.target.value;
                // No need to call createVisualization here, as all data is already generated
                updateDisplay(); // Just update display
            });

            startingArrangementSelect.addEventListener('change', (event) => {
                startingArrangement = event.target.value;
                const wValueSlider = document.getElementById('wValue');
                wValueSlider.disabled = (startingArrangement === 'grid4D');
                if (startingArrangement === 'grid4D') {
                    wValueSlider.style.opacity = '0.3';
                } else {
                    wValueSlider.style.opacity = '1.0';
                }

                createVisualization(); // Regenerate data
                updateDisplay(); // Update display
            });
        }

        function clearVisualization() {
            if (pointsMesh) { scene.remove(pointsMesh); pointsMesh.geometry.dispose(); pointsMesh.material.dispose(); pointsMesh = null; }
            if (linesMesh) { scene.remove(linesMesh); linesMesh.geometry.dispose(); linesMesh.material.dispose(); linesMesh = null; }
            if (facesMesh) { scene.remove(facesMesh); facesMesh.geometry.dispose(); facesMesh.material.dispose(); facesMesh = null; }
            coordinatesDisplayDiv.style.display = 'none';
            currentPointPositionsVector3 = [];
            originalQuaternions = [];
            mappedQuaternions = [];
            originalPointPositions = [];
            originalPointColors = [];
            mappedPointPositions = [];
            mappedPointColors = [];
            originalLinePositions = []; originalLineColors = []; originalLineIndices = [];
            mappedLinePositions = []; mappedLineColors = []; mappedLineIndices = [];
            originalFacePositions = []; originalFaceColors = []; originalFaceIndices = [];
            mappedFacePositions = []; mappedFaceColors = []; mappedFaceIndices = [];
        }

        function vector3ToScreenXY(vector, camera, containerRect) {
            const tempVector = vector.clone();
            tempVector.project(camera);

            const x = (tempVector.x * 0.5 + 0.5) * containerRect.width;
            const y = (tempVector.y * -0.5 + 0.5) * containerRect.height;

            return { x, y };
        }

        function displayPointCoordinates(pointIndex) {
            let quaternionData;
            if (showMappedView) {
                quaternionData = mappedQuaternions[pointIndex];
            } else {
                quaternionData = originalQuaternions[pointIndex];
            }

            if (quaternionData && !isNaN(quaternionData.w)) {
                coordinatesDisplayDiv.innerHTML = `
                    w: ${quaternionData.w.toFixed(4)}<br>
                    x: ${quaternionData.x.toFixed(4)}<br>
                    y: ${quaternionData.y.toFixed(4)}<br>
                    z: ${quaternionData.z.toFixed(4)}
                `;
            } else {
                coordinatesDisplayDiv.innerHTML = `Invalid Point`;
            }
        }

        function onMouseMove(event) {
            const container = document.getElementById('canvas-container');
            const rect = container.getBoundingClientRect();

            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            let closestPointIndex = null;
            let minDistanceSq = Infinity;
            const screenDistanceThresholdSq = (15 * pointSizeFactor) ** 2;

            if (!currentPointPositionsVector3 || currentPointPositionsVector3.length === 0) {
                coordinatesDisplayDiv.style.display = 'none';
                return;
            }

            for (let i = 0; i < currentPointPositionsVector3.length; i++) {
                const point3D = currentPointPositionsVector3[i];

                if (isNaN(point3D.x) || isNaN(point3D.y) || isNaN(point3D.z)) {
                    continue;
                }

                const screenXY = vector3ToScreenXY(point3D, camera, rect);

                const dx = mouseX - screenXY.x;
                const dy = mouseY - screenXY.y;
                const distanceSq = dx * dx + dy * dy;

                if (distanceSq < screenDistanceThresholdSq && distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    closestPointIndex = i;
                }
            }

            if (closestPointIndex !== null) {
                if (intersected !== closestPointIndex) {
                    intersected = closestPointIndex;
                    displayPointCoordinates(intersected);
                }
                coordinatesDisplayDiv.style.left = (event.clientX + 15) + 'px';
                coordinatesDisplayDiv.style.top = (event.clientY + 15) + 'px';
                coordinatesDisplayDiv.style.display = 'block';

            } else {
                if (intersected !== null) {
                    intersected = null;
                    coordinatesDisplayDiv.style.display = 'none';
                }
            }
        }


        function createVisualization() {
            // Clear all data arrays before regenerating
            originalPointPositions = [];
            originalPointColors = [];
            originalLinePositions = [];
            originalLineColors = [];
            originalLineIndices = [];
            originalFacePositions = [];
            originalFaceColors = [];
            originalFaceIndices = [];

            mappedPointPositions = [];
            mappedPointColors = [];
            mappedLinePositions = [];
            mappedLineColors = [];
            mappedLineIndices = [];
            mappedFacePositions = [];
            mappedFaceColors = [];
            mappedFaceIndices = [];

            originalQuaternions = [];
            mappedQuaternions = [];

            const numPoints = density;
            const step = 2.0 / (numPoints - 1);

            let minWInputForColor = parseFloat(document.getElementById('wValue').min);
            let maxWInputForColor = parseFloat(document.getElementById('wValue').max);

            if (startingArrangement === 'grid4D') {
                 minWInputForColor = -1;
                 maxWInputForColor = 1;
            }

            let minOutputW = Infinity;
            let maxOutputW = -Infinity;

            // Generate all original quaternions based on starting arrangement
            if (startingArrangement === 'grid3D') {
                for (let i = 0; i < numPoints; i++) {
                    const x_in = -1 + i * step;
                    for (let j = 0; j < numPoints; j++) {
                        const y_in = -1 + j * step;
                        for (let k = 0; k < numPoints; k++) {
                            const z_in = -1 + k * step;
                            originalQuaternions.push(new Quaternion(wFixed, x_in, y_in, z_in));
                        }
                    }
                }
            } else if (startingArrangement === 'plane2D') {
                const fixedZ = 0;
                for (let i = 0; i < numPoints; i++) {
                    const x_in = -1 + i * step;
                    for (let j = 0; j < numPoints; j++) {
                        const y_in = -1 + j * step;
                        originalQuaternions.push(new Quaternion(wFixed, x_in, y_in, fixedZ));
                    }
                }
            } else if (startingArrangement === 'sphere') {
                const radius = 1;
                const latSegments = density;
                const lonSegments = density * 2;

                for (let lat = 0; lat <= latSegments; lat++) {
                    const theta = lat * Math.PI / latSegments;
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);

                    for (let lon = 0; lon <= lonSegments; lon++) {
                        const phi = lon * 2 * Math.PI / lonSegments;
                        const sinPhi = Math.sin(phi);
                        const cosPhi = Math.cos(phi);

                        const x_in = radius * cosPhi * sinTheta;
                        const y_in = radius * sinPhi * sinTheta;
                        const z_in = radius * cosTheta;
                        originalQuaternions.push(new Quaternion(wFixed, x_in, y_in, z_in));
                    }
                }
            } else if (startingArrangement === 'cubeEdges') {
                const side = 2.0;
                const halfSide = side / 2;
                const pointsPerEdge = density;

                const vertices = [];
                for (let i = -1; i <= 1; i += 2) {
                    for (let j = -1; j <= 1; j += 2) {
                        for (let k = -1; k <= 1; k += 2) {
                            vertices.push(new THREE.Vector3(i * halfSide, j * halfSide, k * halfSide));
                        }
                    }
                }

                const edges = [
                    [0, 1], [1, 3], [3, 2], [2, 0],
                    [4, 5], [5, 7], [7, 6], [6, 4],
                    [0, 4], [1, 5], [3, 7], [2, 6]
                ];

                const addedPointsMap = new Map();

                edges.forEach(edge => {
                    const v1 = vertices[edge[0]];
                    const v2 = vertices[edge[1]];

                    for (let i = 0; i < pointsPerEdge; i++) {
                        const t = i / (pointsPerEdge - 1);
                        const x_in = v1.x * (1 - t) + v2.x * t;
                        const y_in = v1.y * (1 - t) + v2.y * t;
                        const z_in = v1.z * (1 - t) + v2.z * t;

                        const pointKey = `${x_in.toFixed(4)},${y_in.toFixed(4)},${z_in.toFixed(4)}`;
                        if (!addedPointsMap.has(pointKey)) {
                            originalQuaternions.push(new Quaternion(wFixed, x_in, y_in, z_in));
                            addedPointsMap.set(pointKey, originalQuaternions.length - 1);
                        }
                    }
                });
            } else if (startingArrangement === 'cubeFaces') {
                const side = 2.0;
                const halfSide = side / 2;
                const pointsPerFaceDim = numPoints;
                const stepFace = side / (pointsPerFaceDim - 1);

                const generateFacePoints = (fixedAxis, fixedVal) => {
                    for (let i = 0; i < pointsPerFaceDim; i++) {
                        const coord1_val = -halfSide + i * stepFace;
                        for (let j = 0; j < pointsPerFaceDim; j++) {
                            const coord2_val = -halfSide + j * stepFace;
                            if (fixedAxis === 'x') originalQuaternions.push(new Quaternion(wFixed, fixedVal, coord1_val, coord2_val));
                            else if (fixedAxis === 'y') originalQuaternions.push(new Quaternion(wFixed, coord1_val, fixedVal, coord2_val));
                            else originalQuaternions.push(new Quaternion(wFixed, coord1_val, coord2_val, fixedVal));
                        }
                    }
                };

                generateFacePoints('z', halfSide);
                generateFacePoints('z', -halfSide);
                generateFacePoints('y', halfSide);
                generateFacePoints('y', -halfSide);
                generateFacePoints('x', halfSide);
                generateFacePoints('x', -halfSide);
            } else if (startingArrangement === 'grid4D') {
                const grid4DPoints = density;
                const step4D = 2.0 / (grid4DPoints - 1);

                for (let i = 0; i < grid4DPoints; i++) {
                    const w_in = -1 + i * step4D;
                    for (let j = 0; j < grid4DPoints; j++) {
                        const x_in = -1 + j * step4D;
                        for (let l = 0; l < grid4DPoints; l++) {
                            const y_in = -1 + l * step4D;
                            for (let m = 0; m < grid4DPoints; m++) {
                                const z_in = -1 + m * step4D;
                                originalQuaternions.push(new Quaternion(w_in, x_in, y_in, z_in));
                            }
                        }
                    }
                }
            } else if (startingArrangement === 'torus') {
                const majorRadius = 1.0;
                const minorRadius = 0.4;
                const numSegmentsU = density * 2;
                const numSegmentsV = density;

                for (let i = 0; i <= numSegmentsU; i++) {
                    const u = (i / numSegmentsU) * 2 * Math.PI;
                    for (let j = 0; j <= numSegmentsV; j++) {
                        const v = (j / numSegmentsV) * 2 * Math.PI;

                        const x_in = (majorRadius + minorRadius * Math.cos(v)) * Math.cos(u);
                        const y_in = (majorRadius + minorRadius * Math.cos(v)) * Math.sin(u);
                        const z_in = minorRadius * Math.sin(v);
                        originalQuaternions.push(new Quaternion(wFixed, x_in, y_in, z_in));
                    }
                }
            }

            // Evaluate all original quaternions to get mapped quaternions
            for(const q_in of originalQuaternions) {
                const q_out = evaluateQuaternionExpression(currentFunction, q_in);
                mappedQuaternions.push(q_out);

                if (!isNaN(q_out.w)) {
                    minOutputW = Math.min(minOutputW, q_out.w);
                    maxOutputW = Math.max(maxOutputW, q_out.w);
                }
            }

            if (minOutputW === Infinity || maxOutputW === -Infinity || minOutputW === maxOutputW) {
                minOutputW = -5;
                maxOutputW = 5;
            }

            // Populate point positions and colors from the global quaternion arrays
            for (let i = 0; i < originalQuaternions.length; i++) {
                const q_in = originalQuaternions[i];
                const q_out = mappedQuaternions[i];

                if (!isNaN(q_out.x) && !isNaN(q_out.y) && !isNaN(q_out.z)) {
                    originalPointPositions.push(q_in.x, q_in.y, q_in.z);
                    const originalColor = getColor(q_in.w, minWInputForColor, maxWInputForColor);
                    originalPointColors.push(originalColor.r, originalColor.g, originalColor.b);

                    mappedPointPositions.push(q_out.x, q_out.y, q_out.z);
                    const mappedColor = getColor(q_out.w, minOutputW, maxOutputW);
                    mappedPointColors.push(mappedColor.r, mappedColor.g, mappedColor.b);
                }
            }


            const numLineSubdivisions = Math.max(10, Math.floor(20 / density));
            let currentLinePointIdx = 0;

            // Helper to add a line segment using originalQuaternions indices
            const addLineSegment = (idx1, idx2) => {
                const q1_in = originalQuaternions[idx1];
                const q2_in = originalQuaternions[idx2];

                // Skip line if either endpoint's mapped quaternion is invalid
                if (isNaN(mappedQuaternions[idx1].w) || isNaN(mappedQuaternions[idx2].w)) {
                    return;
                }

                for (let s = 0; s <= numLineSubdivisions; s++) {
                    const t = s / numLineSubdivisions;

                    const interp_w_in = q1_in.w * (1 - t) + q2_in.w * t;
                    const interp_x_in = q1_in.x * (1 - t) + q2_in.x * t;
                    const interp_y_in = q1_in.y * (1 - t) + q2_in.y * t;
                    const interp_z_in = q1_in.z * (1 - t) + q2_in.z * t;
                    const q_interp_in = new Quaternion(interp_w_in, interp_x_in, interp_y_in, interp_z_in);

                    const q_interp_out = evaluateQuaternionExpression(currentFunction, q_interp_in);

                    if (isNaN(q_interp_out.w)) {
                        originalLinePositions.push(NaN, NaN, NaN);
                        originalLineColors.push(0, 0, 0);
                        mappedLinePositions.push(NaN, NaN, NaN);
                        mappedLineColors.push(0, 0, 0);
                    } else {
                        originalLinePositions.push(q_interp_in.x, q_interp_in.y, q_interp_in.z);
                        const originalLineColor = getColor(q_interp_in.w, minWInputForColor, maxWInputForColor);
                        originalLineColors.push(originalLineColor.r, originalLineColor.g, originalLineColor.b);

                        mappedLinePositions.push(q_interp_out.x, q_interp_out.y, q_interp_out.z);
                        const mappedLineColor = getColor(q_interp_out.w, minOutputW, maxOutputW);
                        mappedLineColors.push(mappedLineColor.r, mappedLineColor.g, mappedLineColor.b);
                    }


                    if (s > 0) {
                        const prevPointValid = !isNaN(mappedLinePositions[(currentLinePointIdx - 1) * 3]);
                        const currPointValid = !isNaN(mappedLinePositions[currentLinePointIdx * 3]);

                        if (prevPointValid && currPointValid) {
                            originalLineIndices.push(currentLinePointIdx - 1, currentLinePointIdx);
                            mappedLineIndices.push(currentLinePointIdx - 1, currentLinePointIdx);
                        }
                    }
                    currentLinePointIdx++;
                }
            };

            // Helper to add a quad (two triangles) to face data, with subdivision
            const addQuadFaces = (q00_in_corner, q10_in_corner, q01_in_corner, q11_in_corner, minWInputForColor, minOutputW, maxOutputW) => {
                const faceSubdivisions = 5;

                const interpolatedOriginalQuaternions = [];
                const interpolatedMappedQuaternions = [];

                for (let v_step = 0; v_step <= faceSubdivisions; v_step++) {
                    const v = v_step / faceSubdivisions;
                    for (let u_step = 0; u_step <= faceSubdivisions; u_step++) {
                        const u = u_step / faceSubdivisions;

                        const interp_w_in = (1 - u) * (1 - v) * q00_in_corner.w + u * (1 - v) * q10_in_corner.w + (1 - u) * v * q01_in_corner.w + u * v * q11_in_corner.w;
                        const interp_x_in = (1 - u) * (1 - v) * q00_in_corner.x + u * (1 - v) * q10_in_corner.x + (1 - u) * v * q01_in_corner.x + u * v * q11_in_corner.x;
                        const interp_y_in = (1 - u) * (1 - v) * q00_in_corner.y + u * (1 - v) * q10_in_corner.y + (1 - u) * v * q01_in_corner.y + u * v * q11_in_corner.y;
                        const interp_z_in = (1 - u) * (1 - v) * q00_in_corner.z + u * (1 - v) * q10_in_corner.z + (1 - u) * v * q01_in_corner.z + u * v * q11_in_corner.z;
                        const q_interp_in = new Quaternion(interp_w_in, interp_x_in, interp_y_in, interp_z_in);
                        interpolatedOriginalQuaternions.push(q_interp_in);

                        const q_interp_out = evaluateQuaternionExpression(currentFunction, q_interp_in);
                        interpolatedMappedQuaternions.push(q_interp_out);
                    }
                }

                const currentGlobalVertexCountAtStartOfFace = originalFacePositions.length / 3;

                for (let v_sub = 0; v_sub < faceSubdivisions; v_sub++) {
                    for (let u_sub = 0; u_sub < faceSubdivisions; u_sub++) {
                        const p00_idx_local = v_sub * (faceSubdivisions + 1) + u_sub;
                        const p10_idx_local = v_sub * (faceSubdivisions + 1) + (u_sub + 1);
                        const p01_idx_local = (v_sub + 1) * (faceSubdivisions + 1) + u_sub;
                        const p11_idx_local = (v_sub + 1) * (faceSubdivisions + 1) + (u_sub + 1);

                        const p00_in_sub = interpolatedOriginalQuaternions[p00_idx_local];
                        const p10_in_sub = interpolatedOriginalQuaternions[p10_idx_local];
                        const p01_in_sub = interpolatedOriginalQuaternions[p01_idx_local];
                        const p11_in_sub = interpolatedOriginalQuaternions[p11_idx_local];

                        const p00_out_sub = interpolatedMappedQuaternions[p00_idx_local];
                        const p10_out_sub = interpolatedMappedQuaternions[p10_idx_local];
                        const p01_out_sub = interpolatedMappedQuaternions[p01_idx_local];
                        const p11_out_sub = interpolatedMappedQuaternions[p11_idx_local];

                        if (isNaN(p00_out_sub.w) || isNaN(p10_out_sub.w) || isNaN(p01_out_sub.w) || isNaN(p11_out_sub.w)) {
                            continue;
                        }

                        const currentVertexOffset = originalFacePositions.length / 3;

                        originalFacePositions.push(p00_in_sub.x, p00_in_sub.y, p00_in_sub.z);
                        originalFacePositions.push(p10_in_sub.x, p10_in_sub.y, p10_in_sub.z);
                        originalFacePositions.push(p01_in_sub.x, p01_in_sub.y, p01_in_sub.z);
                        originalFacePositions.push(p11_in_sub.x, p11_in_sub.y, p11_in_sub.z);

                        originalFaceColors.push(...getColor(p00_in_sub.w, minWInputForColor, maxWInputForColor).toArray());
                        originalFaceColors.push(...getColor(p10_in_sub.w, minWInputForColor, maxWInputForColor).toArray());
                        originalFaceColors.push(...getColor(p01_in_sub.w, minWInputForColor, maxWInputForColor).toArray());
                        originalFaceColors.push(...getColor(p11_in_sub.w, minWInputForColor, maxWInputForColor).toArray());

                        mappedFacePositions.push(p00_out_sub.x, p00_out_sub.y, p00_out_sub.z);
                        mappedFacePositions.push(p10_out_sub.x, p10_out_sub.y, p10_out_sub.z);
                        mappedFacePositions.push(p01_out_sub.x, p01_out_sub.y, p01_out_sub.z);
                        mappedFacePositions.push(p11_out_sub.x, p11_out_sub.y, p11_out_sub.z);

                        mappedFaceColors.push(...getColor(p00_out_sub.w, minOutputW, maxOutputW).toArray());
                        mappedFaceColors.push(...getColor(p10_out_sub.w, minOutputW, maxOutputW).toArray());
                        mappedFaceColors.push(...getColor(p01_out_sub.w, minOutputW, maxOutputW).toArray());
                        mappedFaceColors.push(...getColor(p11_out_sub.w, minOutputW, maxOutputW).toArray());

                        originalFaceIndices.push(currentVertexOffset, currentVertexOffset + 1, currentVertexOffset + 2);
                        mappedFaceIndices.push(currentVertexOffset, currentVertexOffset + 1, currentVertexOffset + 2);

                        originalFaceIndices.push(currentVertexOffset + 1, currentVertexOffset + 3, currentVertexOffset + 2);
                        mappedFaceIndices.push(currentVertexOffset + 1, currentVertexOffset + 3, currentVertexOffset + 2);
                    }
                }
            };


            // Generate lines and faces for each arrangement type
            if (startingArrangement === 'grid3D') {
                const getGridIdx = (i, j, k) => i * numPoints * numPoints + j * numPoints + k;

                for (let i = 0; i < numPoints; i++) {
                    for (let j = 0; j < numPoints; j++) {
                        for (let k = 0; k < numPoints; k++) {
                            const currentIdx = getGridIdx(i, j, k);

                            if (i < numPoints - 1) {
                                addLineSegment(currentIdx, getGridIdx(i + 1, j, k));
                            }
                            if (j < numPoints - 1) {
                                addLineSegment(currentIdx, getGridIdx(i, j + 1, k));
                            }
                            if (k < numPoints - 1) {
                                addLineSegment(currentIdx, getGridIdx(i, j, k + 1));
                            }
                        }
                    }
                }

                // Always generate faces for grid3D, display handled by updateDisplay()
                for (let i = 0; i < numPoints - 1; i++) {
                    for (let j = 0; j < numPoints - 1; j++) {
                        addQuadFaces(originalQuaternions[getGridIdx(i, j, 0)], originalQuaternions[getGridIdx(i + 1, j, 0)], originalQuaternions[getGridIdx(i, j + 1, 0)], originalQuaternions[getGridIdx(i + 1, j + 1, 0)], minWInputForColor, minOutputW, maxOutputW);
                        addQuadFaces(originalQuaternions[getGridIdx(i, j, numPoints - 1)], originalQuaternions[getGridIdx(i + 1, j, numPoints - 1)], originalQuaternions[getGridIdx(i, j + 1, numPoints - 1)], originalQuaternions[getGridIdx(i + 1, j + 1, numPoints - 1)], minWInputForColor, minOutputW, maxOutputW);
                    }
                }

                for (let i = 0; i < numPoints - 1; i++) {
                    for (let k = 0; k < numPoints - 1; k++) {
                        addQuadFaces(originalQuaternions[getGridIdx(i, 0, k)], originalQuaternions[getGridIdx(i + 1, 0, k)], originalQuaternions[getGridIdx(i, 0, k + 1)], originalQuaternions[getGridIdx(i + 1, 0, k + 1)], minWInputForColor, minOutputW, maxOutputW);
                        addQuadFaces(originalQuaternions[getGridIdx(i, numPoints - 1, k)], originalQuaternions[getGridIdx(i + 1, numPoints - 1, k)], originalQuaternions[getGridIdx(i, numPoints - 1, k + 1)], originalQuaternions[getGridIdx(i + 1, numPoints - 1, k + 1)], minWInputForColor, minOutputW, maxOutputW);
                    }
                }

                for (let j = 0; j < numPoints - 1; j++) {
                    for (let k = 0; k < numPoints - 1; k++) {
                        addQuadFaces(originalQuaternions[getGridIdx(0, j, k)], originalQuaternions[getGridIdx(0, j + 1, k)], originalQuaternions[getGridIdx(0, j, k + 1)], originalQuaternions[getGridIdx(0, j + 1, k + 1)], minWInputForColor, minOutputW, maxOutputW);
                        addQuadFaces(originalQuaternions[getGridIdx(numPoints - 1, j, k)], originalQuaternions[getGridIdx(numPoints - 1, j + 1, k)], originalQuaternions[getGridIdx(numPoints - 1, j, k + 1)], originalQuaternions[getGridIdx(numPoints - 1, j + 1, k + 1)], minWInputForColor, minOutputW, maxOutputW);
                    }
                }

            } else if (startingArrangement === 'plane2D') {
                for (let i = 0; i < numPoints; i++) {
                    for (let j = 0; j < numPoints; j++) {
                        const currentIdx = i * numPoints + j;

                        if (i < numPoints - 1) {
                            const nextXIdx = (i + 1) * numPoints + j;
                            addLineSegment(currentIdx, nextXIdx);
                        }
                        if (j < numPoints - 1) {
                            const nextYIdx = i * numPoints + (j + 1);
                            addLineSegment(currentIdx, nextYIdx);
                        }

                        // Always generate faces for plane2D, display handled by updateDisplay()
                        if (i < numPoints - 1 && j < numPoints - 1) {
                            const p1_idx = currentIdx;
                            const p2_idx = i * numPoints + (j + 1);
                            const p3_idx = (i + 1) * numPoints + j;
                            const p4_idx = (i + 1) * numPoints + (j + 1);
                            addQuadFaces(originalQuaternions[p1_idx], originalQuaternions[p2_idx], originalQuaternions[p3_idx], originalQuaternions[p4_idx], minWInputForColor, minOutputW, maxOutputW);
                        }
                    }
                }
            } else if (startingArrangement === 'sphere') {
                const latSegments = density;
                const lonSegments = density * 2;

                for (let lat = 0; lat <= latSegments; lat++) {
                    for (let lon = 0; lon <= lonSegments; lon++) {
                        const currentIdx = lat * (lonSegments + 1) + lon;

                        if (lon < lonSegments) {
                            const nextLonIdx = lat * (lonSegments + 1) + lon + 1;
                            addLineSegment(currentIdx, nextLonIdx);
                        }
                        if (lat < latSegments) {
                            const nextLatIdx = (lat + 1) * (lonSegments + 1) + lon;
                            addLineSegment(currentIdx, nextLatIdx);
                        }
                        // Faces are explicitly NOT generated for sphere as per user request.
                    }
                }
            } else if (startingArrangement === 'cubeEdges') {
                const side = 2.0;
                const halfSide = side / 2;
                const pointsPerEdge = density;

                const vertices = [];
                for (let i = -1; i <= 1; i += 2) {
                    for (let j = -1; j <= 1; j += 2) {
                        for (let k = -1; k <= 1; k += 2) {
                            vertices.push(new THREE.Vector3(i * halfSide, j * halfSide, k * halfSide));
                        }
                    }
                }

                const edges = [
                    [0, 1], [1, 3], [3, 2], [2, 0],
                    [4, 5], [5, 7], [7, 6], [6, 4],
                    [0, 4], [1, 5], [3, 7], [2, 6]
                ];

                const getQuaternionIndex = (w, x, y, z, tolerance = 0.0001) => {
                    for (let i = 0; i < originalQuaternions.length; i++) {
                        const q = originalQuaternions[i];
                        if (Math.abs(q.w - w) < tolerance &&
                            Math.abs(q.x - x) < tolerance &&
                            Math.abs(q.y - y) < tolerance &&
                            Math.abs(q.z - z) < tolerance) {
                            return i;
                        }
                    }
                    return -1;
                };

                edges.forEach(edge => {
                    const v1 = vertices[edge[0]];
                    const v2 = vertices[edge[1]];

                    for (let i = 0; i < pointsPerEdge - 1; i++) {
                        const t1 = i / (pointsPerEdge - 1);
                        const t2 = (i + 1) / (pointsPerEdge - 1);

                        const q1_x = v1.x * (1 - t1) + v2.x * t1;
                        const q1_y = v1.y * (1 - t1) + v2.y * t1;
                        const q1_z = v1.z * (1 - t1) + v2.z * t1;
                        const q1_w = wFixed;

                        const q2_x = v1.x * (1 - t2) + v2.x * t2;
                        const q2_y = v1.y * (1 - t2) + v2.y * t2;
                        const q2_z = v1.z * (1 - t2) + v2.z * t2;
                        const q2_w = wFixed;

                        const idx1 = getQuaternionIndex(q1_w, q1_x, q1_y, q1_z);
                        const idx2 = getQuaternionIndex(q2_w, q2_x, q2_y, q2_z);

                        if (idx1 !== -1 && idx2 !== -1) {
                            addLineSegment(idx1, idx2);
                        }
                    }
                });
            } else if (startingArrangement === 'cubeFaces') {
                const pointsPerFaceDim = numPoints;
                const generateFaceLinesAndQuads = (base_idx_offset) => {
                    for (let i = 0; i < pointsPerFaceDim; i++) {
                        for (let j = 0; j < pointsPerFaceDim; j++) {
                            const currentIdx = base_idx_offset + i * pointsPerFaceDim + j;

                            if (i < pointsPerFaceDim - 1) {
                                const nextIdx = base_idx_offset + (i + 1) * pointsPerFaceDim + j;
                                addLineSegment(currentIdx, nextIdx);
                            }
                            if (j < pointsPerFaceDim - 1) {
                                const nextIdx = base_idx_offset + i * pointsPerFaceDim + (j + 1);
                                addLineSegment(currentIdx, nextIdx);
                            }

                            // Always generate faces for cubeFaces, display handled by updateDisplay()
                            if (i < pointsPerFaceDim - 1 && j < pointsPerFaceDim - 1) {
                                const p1_idx = currentIdx;
                                const p2_idx = base_idx_offset + i * pointsPerFaceDim + (j + 1);
                                const p3_idx = base_idx_offset + (i + 1) * pointsPerFaceDim + j;
                                const p4_idx = base_idx_offset + (i + 1) * pointsPerFaceDim + (j + 1);
                                addQuadFaces(originalQuaternions[p1_idx], originalQuaternions[p2_idx], originalQuaternions[p3_idx], originalQuaternions[p4_idx], minWInputForColor, minOutputW, maxOutputW);
                            }
                        }
                    }
                };

                let currentOffset = 0;
                generateFaceLinesAndQuads(currentOffset);
                currentOffset += pointsPerFaceDim * pointsPerFaceDim;
                generateFaceLinesAndQuads(currentOffset);
                currentOffset += pointsPerFaceDim * pointsPerFaceDim;
                generateFaceLinesAndQuads(currentOffset);
                currentOffset += pointsPerFaceDim * pointsPerFaceDim;
                generateFaceLinesAndQuads(currentOffset);
                currentOffset += pointsPerFaceDim * pointsPerFaceDim;
                generateFaceLinesAndQuads(currentOffset);
                currentOffset += pointsPerFaceDim * pointsPerFaceDim;
                generateFaceLinesAndQuads(currentOffset);

            } else if (startingArrangement === 'grid4D') {
                const grid4DPoints = density;

                for (let i = 0; i < grid4DPoints; i++) {
                    for (let j = 0; j < grid4DPoints; j++) {
                        for (let l = 0; l < grid4DPoints; l++) {
                            for (let m = 0; m < grid4DPoints; m++) {
                                const currentIdx = i * (grid4DPoints**3) + j * (grid4DPoints**2) + l * grid4DPoints + m;

                                if (i < grid4DPoints - 1) {
                                    const nextWIdx = (i + 1) * (grid4DPoints**3) + j * (grid4DPoints**2) + l * grid4DPoints + m;
                                    addLineSegment(currentIdx, nextWIdx);
                                }
                                if (j < grid4DPoints - 1) {
                                    const nextXIdx = i * (grid4DPoints**3) + (j + 1) * (grid4DPoints**2) + l * grid4DPoints + m;
                                    addLineSegment(currentIdx, nextXIdx);
                                }
                                if (l < grid4DPoints - 1) {
                                    const nextYIdx = i * (grid4DPoints**3) + j * (grid4DPoints**2) + (l + 1) * grid4DPoints + m;
                                    addLineSegment(currentIdx, nextYIdx);
                                }
                                if (m < grid4DPoints - 1) {
                                    const nextZIdx = i * (grid4DPoints**3) + j * (grid4DPoints**2) + l * grid4DPoints + (m + 1);
                                    addLineSegment(currentIdx, nextZIdx);
                                }
                                // Faces are explicitly NOT generated for 4D grid as per user request.
                            }
                        }
                    }
                }
            } else if (startingArrangement === 'torus') {
                const numSegmentsU = density * 2;
                const numSegmentsV = density;

                for (let i = 0; i <= numSegmentsU; i++) {
                    for (let j = 0; j <= numSegmentsV; j++) {
                        const currentIdx = i * (numSegmentsV + 1) + j;

                        if (i < numSegmentsU) {
                            const nextUIdx = (i + 1) * (numSegmentsV + 1) + j;
                            addLineSegment(currentIdx, nextUIdx);
                        }
                        if (j < numSegmentsV) {
                            const nextVIdx = i * (numSegmentsV + 1) + (j + 1);
                            addLineSegment(currentIdx, nextVIdx);
                        }

                        // Always generate faces for torus, display handled by updateDisplay()
                        if (i < numSegmentsU && j < numSegmentsV) {
                            const p1_idx = currentIdx;
                            const p2_idx = i * (numSegmentsV + 1) + (j + 1);
                            const p3_idx = (i + 1) * (numSegmentsV + 1) + j;
                            const p4_idx = (i + 1) * (numSegmentsV + 1) + (j + 1);
                            addQuadFaces(originalQuaternions[p1_idx], originalQuaternions[p2_idx], originalQuaternions[p3_idx], originalQuaternions[p4_idx], minWInputForColor, minOutputW, maxOutputW);
                        }
                    }
                }
            }
        }

        function updateDisplay() {
            // Remove existing meshes from the scene
            if (pointsMesh) {
                scene.remove(pointsMesh);
                pointsMesh.geometry.dispose();
                pointsMesh.material.dispose();
                pointsMesh = null;
            }
            if (linesMesh) {
                scene.remove(linesMesh);
                linesMesh.geometry.dispose();
                linesMesh.material.dispose();
                linesMesh = null;
            }
            if (facesMesh) {
                scene.remove(facesMesh);
                facesMesh.geometry.dispose();
                facesMesh.material.dispose();
                facesMesh = null;
            }


            const currentPointPositions = showMappedView ? mappedPointPositions : originalPointPositions;
            const currentPointColors = showMappedView ? mappedPointColors : originalPointColors;
            const currentLinePositions = showMappedView ? mappedLinePositions : originalLinePositions;
            const currentLineColors = showMappedView ? mappedLineColors : originalLineColors;
            const currentLineIndices = showMappedView ? mappedLineIndices : originalLineIndices;

            const currentFacePositions = showMappedView ? mappedFacePositions : originalFacePositions;
            const currentFaceColors = showMappedView ? mappedFaceColors : originalFaceColors;
            const currentFaceIndices = showMappedView ? mappedFaceIndices : originalFaceIndices;


            if (currentPointPositions.length === 0) {
                coordinatesDisplayDiv.style.display = 'none';
                return;
            }

            const basePointSize = 0.0245;
            const initialDensity = 20;
            const pointSize = (basePointSize * (initialDensity / density)) * pointSizeFactor;

            const pointGeometry = new THREE.BufferGeometry();
            pointGeometry.setAttribute('position', new THREE.Float32BufferAttribute(currentPointPositions, 3));
            pointGeometry.setAttribute('color', new THREE.Float32BufferAttribute(currentPointColors, 3));

            const pointMaterial = new THREE.PointsMaterial({
                size: pointSize,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                map: circleTexture,
                alphaTest: 0.1
            });

            pointsMesh = new THREE.Points(pointGeometry, pointMaterial);
            scene.add(pointsMesh);

            currentPointPositionsVector3 = [];
            const positionsAttribute = pointGeometry.attributes.position;
            for (let i = 0; i < positionsAttribute.count; i++) {
                currentPointPositionsVector3.push(new THREE.Vector3().fromBufferAttribute(positionsAttribute, i));
            }


            if (lineDisplayMode === 'show' && currentLineIndices.length > 0) {
                const lineGeometry = new THREE.BufferGeometry();
                lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(currentLinePositions, 3));
                lineGeometry.setAttribute('color', new THREE.Float32BufferAttribute(currentLineColors, 3));
                lineGeometry.setIndex(new THREE.Uint32BufferAttribute(currentLineIndices, 1));

                const lineMaterial = new THREE.LineBasicMaterial({ vertexColors: true, linewidth: 1 });
                linesMesh = new THREE.LineSegments(lineGeometry, lineMaterial);
                scene.add(linesMesh);
            } else if (lineDisplayMode === 'faces' && currentFaceIndices.length > 0) {
                const faceGeometry = new THREE.BufferGeometry();
                faceGeometry.setAttribute('position', new THREE.Float32BufferAttribute(currentFacePositions, 3));
                faceGeometry.setAttribute('color', new THREE.Float32BufferAttribute(currentFaceColors, 3));
                faceGeometry.setIndex(new THREE.Uint32BufferAttribute(currentFaceIndices, 1));

                const faceMaterial = new THREE.MeshBasicMaterial({
                    vertexColors: true,
                    side: THREE.DoubleSide,
                    transparent: false,
                    opacity: 1.0
                });
                facesMesh = new THREE.Mesh(faceGeometry, faceMaterial);
                scene.add(facesMesh);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        window.onload = function () {
            init();
            animate();
        };
    </script>
</body>
</html>
